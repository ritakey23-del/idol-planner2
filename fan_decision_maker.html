<script>
        // --- JavaScript 邏輯區域 ---

        const optionsInput = document.getElementById('options-input');
        const resultDisplay = document.getElementById('result-display');
        const saveStatus = document.getElementById('save-status');
        const wheelCanvas = document.getElementById('wheelCanvas');
        const ctx = wheelCanvas.getContext('2d');
        const STORAGE_KEY = 'fanSpinnerOptions';

        // 轉盤繪製參數
        const centerX = wheelCanvas.width / 2;
        const centerY = wheelCanvas.height / 2;
        const radius = Math.min(centerX, centerY) - 10;
        const colors = ['#FFD1DC', '#FFC0CB', '#FFB6C1', '#FF69B4', '#DA70D6', '#BA55D3', '#9370DB', '#8A2BE2', '#4B0082', '#6A5ACD', '#483D8B', '#0000FF', '#0000CD', '#00008B', '#00BFFF', '#87CEEB', '#ADD8E6', '#B0E0E6', '#AFEEEE', '#00FFFF', '#E0FFFF', '#AFEEEE', '#00CED1', '#40E0D0', '#48D1CC', '#20B2AA', '#008B8B', '#008080', '#5F9EA0', '#8FBC8F', '#3CB371', '#2E8B57', '#006400', '#008000', '#228B22', '#32CD32', '#9ACD32', '#ADFF2F', '#7FFF00', '#7CFC00', '#6B8E23', '#556B2F', '#808000', '#BDB76B', '#DAA520', '#FFD700', '#FFA500', '#FF8C00', '#FF7F50', '#FF6347', '#FF4500', '#FF0000', '#DC143C', '#B22222', '#8B0000'];


        let currentRotation = 0;
        let isSpinning = false;
        let options = [];

        // --- Helper: 文字換行邏輯 (略，同前版) ---
        function wrapText(ctx, text, maxWidth) {
            const words = text.split('');
            let line = '';
            let lines = [];
            for (let n = 0; n < words.length; n++) {
                const word = words[n];
                const testLine = line + word;
                const metrics = ctx.measureText(testLine);
                const testWidth = metrics.width;
                if (testWidth > maxWidth && line.length > 0) {
                    lines.push(line);
                    line = word;
                } else {
                    line = testLine;
                }
            }
            lines.push(line);
            return lines;
        }

        // --- 1. 資料持久化 (略，同前版) ---
        function loadOptions() {
            const savedOptions = localStorage.getItem(STORAGE_KEY);
            if (savedOptions) {
                optionsInput.value = savedOptions;
            }
            options = getCleanedOptions();
            drawWheel();
            drawPointer();
        }
        
        function saveOptions() {
            localStorage.setItem(STORAGE_KEY, optionsInput.value);
            saveStatus.textContent = '列表已自動儲存。';
            saveStatus.style.opacity = 1;
            setTimeout(() => {
                saveStatus.style.opacity = 0;
            }, 1500);
            
            options = getCleanedOptions();
            drawWheel();
            drawPointer();
        }
        
        function getCleanedOptions() {
            return optionsInput.value
                .split('\n')
                .map(line => line.trim())
                .filter(line => line.length > 0);
        }

        // --- 2. 繪製轉盤 (略，同前版) ---
        function drawWheel() {
            ctx.clearRect(0, 0, wheelCanvas.width, wheelCanvas.height);

            if (options.length === 0) {
                ctx.font = '16px Arial';
                ctx.fillStyle = '#666';
                ctx.textAlign = 'center';
                ctx.fillText('請輸入選項', centerX, centerY);
                return;
            }

            const arcAngle = (2 * Math.PI) / options.length;

            for (let i = 0; i < options.length; i++) {
                const startAngle = i * arcAngle;
                const endAngle = (i + 1) * arcAngle;
                const segmentColor = colors[i % colors.length];

                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.lineTo(centerX, centerY);
                ctx.fillStyle = segmentColor;
                ctx.fill();
                ctx.strokeStyle = '#ccc';
                ctx.lineWidth = 1;
                ctx.stroke();

                // 繪製文字 
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(startAngle + arcAngle / 2); 
                
                ctx.textAlign = 'center'; 
                ctx.textBaseline = 'middle';
                
                const textColor = '#000000'; 
                ctx.fillStyle = textColor;
                ctx.font = 'bold 16px Arial'; 
                
                const maxWidth = radius * 0.7; 
                const lineHeight = 18; 
                const lines = wrapText(ctx, options[i], maxWidth);
                
                const totalTextHeight = lines.length * lineHeight;
                let textY = -totalTextHeight / 2 + lineHeight / 2;
                const textX = radius * 0.55; 
                
                for(let j = 0; j < lines.length; j++) {
                    ctx.fillText(lines[j], textX, textY);
                    textY += lineHeight;
                }
                
                ctx.restore();
            }
        }
        
        // --- 3. 繪製中心指標 (略，同前版) ---
        function drawPointer() {
            ctx.save();
            
            ctx.beginPath();
            ctx.strokeStyle = '#D9004C';
            ctx.lineWidth = 3;
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(centerX, centerY - radius); 
            ctx.stroke();

            const centerRadius = radius * 0.15;
            ctx.beginPath();
            ctx.arc(centerX, centerY, centerRadius, 0, 2 * Math.PI);
            ctx.fillStyle = isSpinning ? '#CCCCCC' : '#D9004C'; 
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.stroke();
            
            ctx.font = 'bold 16px Arial';
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(isSpinning ? 'GO!' : 'SPIN', centerX, centerY);
            
            ctx.restore();
        }

        // --- 4. 點擊偵測邏輯 (略，同前版) ---
        function isClickInsideCenter(clickX, clickY) {
            const distance = Math.sqrt(Math.pow(clickX - centerX, 2) + Math.pow(clickY - centerY, 2));
            const centerRadius = radius * 0.15;
            return distance < centerRadius;
        }

        function handleCanvasClick(event) {
            const rect = wheelCanvas.getBoundingClientRect();
            const x = event.clientX - rect.left; 
            const y = event.clientY - rect.top;

            if (isClickInsideCenter(x, y) && !isSpinning && options.length > 0) {
                spinWheel();
            }
        }

        // --- 5. 轉盤動畫邏輯 (核心修正區: 增加 180度反轉校準) ---
        function spinWheel() {
            options = getCleanedOptions();
            if (options.length === 0) {
                alert("請至少輸入一個選項！");
                return;
            }
            if (isSpinning) return;

            isSpinning = true;
            resultDisplay.classList.remove('highlight-result');
            resultDisplay.classList.remove('spinning');
            resultDisplay.textContent = '轉動中...';

            const totalSpins = 5 + Math.random() * 2;
            const targetIndex = Math.floor(Math.random() * options.length); // 最終要顯示的獲勝 Index
            
            const arcAngle = (2 * Math.PI) / options.length; 
            const targetAngleOffset = targetIndex * arcAngle + arcAngle / 2; // 目標 segment 的中心角度
            
            const topPositionAngle = 3 * Math.PI / 2; // 箭頭在 270度

            // 1. 計算將目標 segment 轉到 270度需要的角度
            let rotationToTarget = (topPositionAngle - targetAngleOffset) % (2 * Math.PI);
            if (rotationToTarget < 0) {
                rotationToTarget += 2 * Math.PI;
            }
            
            // 2. 增加 180度 (Math.PI) 修正，以翻轉視覺結果
            const VISUAL_FLIP = Math.PI; 
            
            // 總旋轉角度 = 至少轉 N 圈 + 停在目標位置的精確角度 + 180度反轉
            const finalRotation = (totalSpins * 2 * Math.PI) + rotationToTarget + VISUAL_FLIP; 
            
            let startTime = null;
            const duration = 4000;

            function animateSpin(timestamp) {
                if (!startTime) startTime = timestamp;
                const elapsed = timestamp - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                const easedProgress = 1 - Math.pow(1 - progress, 3);
                
                currentRotation = easedProgress * finalRotation;

                ctx.clearRect(0, 0, wheelCanvas.width, wheelCanvas.height);
                
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(currentRotation);
                ctx.translate(-centerX, -centerY);
                drawWheel();
                ctx.restore(); 

                drawPointer();
                
                if (progress < 1) {
                    requestAnimationFrame(animateSpin);
                } else {
                    // 動畫結束
                    isSpinning = false;
                    resultDisplay.classList.add('highlight-result');
                    resultDisplay.textContent = `恭喜你！結果是：「${options[targetIndex]}」`;
                    drawPointer(); // 最終顯示狀態
                }
            }
            resultDisplay.classList.add('spinning');
            requestAnimationFrame(animateSpin);
        }

        // --- 6. 事件綁定與初始化 ---
        wheelCanvas.addEventListener('click', handleCanvasClick);
        optionsInput.addEventListener('input', saveOptions);
        
        loadOptions();
        
    </script>
