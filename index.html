<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ËøΩÊòüË¶èÂäÉ‰∏≠ÂøÉ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        // È°çÂ§ñÂåØÂÖ• writeBatch, runTransaction
        import { getFirestore, doc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // =========================================================
        // ‚ö†Ô∏è „ÄêÈáçË¶ÅÔºöË´ãÊõøÊèõÁÇ∫ÊÇ®Ëá™Â∑±ÁöÑ Firebase ÈÖçÁΩÆ„Äë
        //    Â∞áÊÇ®Â∞àÊ°àÁöÑÁúüÂØ¶ÈÖçÁΩÆË≤ºÂà∞ÈÄôË£°Ôºå‰ª•Á¢∫‰øù GitHub Pages ËÉΩÊàêÂäüÈÄ£Á∑ö„ÄÇ
        // =========================================================
        const firebaseConfig = {
            // apiKey: "YOUR_API_KEY", 
            // authDomain: "YOUR_PROJECT_ID.firebaseapp.com",
            // projectId: "YOUR_PROJECT_ID",
            // storageBucket: "YOUR_PROJECT_ID.appspot.com",
            // messagingSenderId: "YOUR_SENDER_ID",
            // appId: "YOUR_APP_ID" 
        };

        // Áî±ÊñºÁ°¨Á∑®Á¢º‰∫ÜÈÖçÁΩÆÔºåÈÄô‰∫õËÆäÊï∏ÁèæÂú®ÂèØ‰ª•Áõ¥Êé•ÂæûÈÖçÁΩÆ‰∏≠Áç≤ÂèñÊàñË®≠ÁÇ∫ null/È†êË®≠ÂÄº
        const appId = firebaseConfig.appId || 'default-app-id'; // ÂæûÈÖçÁΩÆ‰∏≠ËÆÄÂèñÊàñ‰ΩøÁî®È†êË®≠ÂÄº
        const initialAuthToken = null; // ‰∏ç‰ΩøÁî®Ëá™ÂÆöÁæ© Token

        let app, db, auth;
        let unsubscribeEvents = null;
        let unsubscribeColors = null;
        let unsubscribeTheme = null;
        // ... (ÁúÅÁï• Vue 3 Setup ÈÉ®ÂàÜ) ...
        const { createApp, ref, computed, watch } = Vue;
        // È†êË®≠È°èËâ≤ÂíåÊáâÊè¥Ëâ≤ÂàóË°®
        const DEFAULT_COLOR_CLASS = 'border-gray-400';
        // Fallback
        const INITIAL_APP_THEME_HEX = '#4FBDBA';
        // È†êË®≠ÁöÑÊπñÊ∞¥Á∂† HEX Ëâ≤Á¢º

        // ËºîÂä©ÂáΩÊï∏ÔºöÂ∞á HEX ËΩâÊèõÁÇ∫ RGB Êï∏ÁµÑ
        const hexToRgb = (hex) => {
            const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
            hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [
                parseInt(result[1], 16),
                parseInt(result[2], 16),
                parseInt(result[3], 16)
            ] : [79, 189, 186];
        // Fallback to aquamarine RGB
        };
        // ËºîÂä©ÂáΩÊï∏ÔºöÂ∞á HEX ËΩâÊèõÁÇ∫ Tailwind Border Class
        const hexToBorderClass = (hex) => {
             // ÁßªÈô§ # Á¨¶ËôüÔºåÁî®Êñº CSS ËÆäÊï∏ÊàñÁõ¥Êé•‰ΩúÁÇ∫È°ûÂêçÔºàÈõñÁÑ∂‰∏çÊòØÊ®ôÊ∫ñ TailwindÔºâ
            return `border-[${hex.startsWith('#') ?
hex : '#' + hex}]`;
        };

        const EventTracker = {
            setup() {
                // --- ÁãÄÊÖãÁÆ°ÁêÜ ---
                const isAuthReady = ref(false);
                const userId = ref(null);
                const loading = ref(true);
                const events = ref([]);
                const activeEventId = ref(null);
                const activeTab = ref('schedule');
                const selectedReviewYear = ref('all'); 
                const showExclusionDisclaimer = ref(false); 
                
                // Theme State
                const currentAppThemeHex = ref(INITIAL_APP_THEME_HEX);
                const newThemeSelectionHex = ref(INITIAL_APP_THEME_HEX);
                
                // Color State
                const fanColors = ref({});
                const showColorModal = ref(false);
                const newColorArtist = ref('');
                const newColorClass = ref('#EF4444');
                // Default HEX 

                // Form States
                const newEventName = ref('');
                const newArtistName = ref('');
                const showEventModal = ref(false);
                const showEditModal = ref(false); 
                const showEntrySelectionModal = ref(false);
                // NEW: Entry Selection Modal
                const newEventDate = ref('');
                const newEventLocation = ref('');
                
                // NEW/MODIFIED Schedule/Expense fields
                const newSchedule = ref({ 
                    time: '09:00', 
                    location: '', 
                    description: '', 
       
                    expenseAmount: 0, 
                    expenseDescription: '' 
                });
                const newExpense = ref({ description: '', amount: 0 }); // Retained for convenience but unused in expense tab
                const newParticipant = ref('');
                const selectedFile = ref(null); 
                const isImporting = ref(false);
                const showImportModal = ref(false); 
                const showDailyItemModal = ref(false);
                // Á∑®ËºØË°®ÂñÆÁöÑÊö´Â≠òÁãÄÊÖã - ADDED time
                const editEventForm = ref({
                    eventName: '',
                    artistName: '',
                    date: '',
              
                    time: '', // NEW: Ê¥ªÂãïÊôÇÈñì
                    mainLocation: '',
                    baseTicketExpense: 0,
                    id: null
                });
                
                // =========================================================
                // üöÄ „ÄêÊñ∞Â¢ûÔºöÂÖßÂª∫È†êË®≠Ê¥ªÂãïÊï∏Êìö„Äë
                //    Ë´ãÂ∞áÊÇ®ÁöÑ CSV ËΩâÁÇ∫‰ª•‰∏ã JSON Ê†ºÂºè„ÄÇ
                // =========================================================
                const DEFAULT_EVENTS = [
                    {
                        eventName: 'TWICE Ready To Be ‰∏ñÁïåÂ∑°Ëø¥',
                        artistName: 'TWICE',
                        year: 2023,
                        date: '2023-09-03',
                        mainLocation: 'Âè∞ÂåóÂ∞èÂ∑®Ëõã',
                        baseTicketExpense: 4800,
                        participants: ['Êàë', 'Â∞èÊòé'],
                        dailyItems: [
                            { time: '17:30', location: 'Âè∞ÂåóÂ∞èÂ∑®Ëõã', description: 'Á≠âÂæÖÂÖ•Â†¥', expenseAmount: 0, expenseDescription: '', id: 'item1' },
                            { time: '18:00', location: 'Âè∞ÂåóÂ∞èÂ∑®Ëõã', description: 'ÊºîÂî±ÊúÉÈñãÂßã', expenseAmount: 0, expenseDescription: '', id: 'item2' },
                            { time: '14:00', location: 'Âø†Â≠ùÂæ©ËààÁ´ô', description: 'ÂçàÈ§ê - ÊáâÊè¥‰∏ªÈ°åÈ§êÂª≥', expenseAmount: 550, expenseDescription: '‰∏ªÈ°åÈ§êÂª≥Ë≤ªÁî®', id: 'item3' },
                        ],
                    },
                    {
                        eventName: 'IU H.E.R. ‰∏ñÁïåÂ∑°Ëø¥ÊºîÂî±ÊúÉ',
                        artistName: 'IU',
                        year: 2024,
                        date: '2024-04-06',
                        mainLocation: 'Âè∞ÂåóÂ∞èÂ∑®Ëõã',
                        baseTicketExpense: 6800,
                        participants: ['Êàë'],
                        dailyItems: [],
                    },
                    {
                        eventName: '‰∫ãÂâçÈåÑË£Ω - M!COUNTDOWN',
                        artistName: 'LE SSERAFIM',
                        year: 2024,
                        date: '2024-03-28',
                        mainLocation: 'CJ E&M Studio',
                        baseTicketExpense: 0,
                        participants: ['Êàë'],
                        dailyItems: [
                            { time: '07:00', location: 'Studio', description: 'ÈåÑË£ΩÈõÜÂêà', expenseAmount: 120, expenseDescription: 'Êó©È§êË≤ªÁî®', id: 'item4' },
                        ],
                    },
                ];
                // =========================================================
                
                // --- Methods / Utilities ---

                // UPDATED: Áç≤ÂèñÊáâÊè¥Ëâ≤ Tailwind Class (‰ΩøÁî® HEX Á∂ÅÂÆö)
                const getFanColorClass = (artistName) => {
                    const hex = fanColors.value[artistName] ||
DEFAULT_COLOR_CLASS;
                    // Â¶ÇÊûúÊòØ HEX (#XXXXXX)ÔºåÂâáËøîÂõû Tailwind JIT Ê†ºÂºè
                    if (hex.startsWith('#')) {
                        return hexToBorderClass(hex);
                    }
                    // Â¶ÇÊûú‰∏çÊòØ HEX (‰æãÂ¶Ç 'border-gray-400')ÔºåÂâáÂéüÊ®£ËøîÂõû
                    return hex;
                };
                
                const applyTheme = (hexColor) => {
                    const root = document.documentElement.style;
                    const [r, g, b] = hexToRgb(hexColor);
                    
                    // Set primary theme color variables based on the user's HEX input
                    root.setProperty('--theme-hex', hexColor);
                    root.setProperty('--theme-rgb', `${r}, ${g}, ${b}`);
                    root.setProperty('--theme-50', `rgba(${r}, ${g}, ${b}, 0.05)`); // Lightest background
                    root.setProperty('--theme-100', `rgba(${r}, ${g}, ${b}, 0.1)`);
                    root.setProperty('--theme-400', `rgba(${r}, ${g}, ${b}, 0.6)`); // Used for borders, lighter elements
                    root.setProperty('--theme-500', `rgba(${r}, ${g}, ${b}, 0.8)`);
                    // Main buttons/nav color
                    root.setProperty('--theme-600', `rgba(${r}, ${g}, ${b}, 0.9)`);
                    root.setProperty('--theme-700', `rgba(${r}, ${g}, ${b}, 1)`); // Text color
                    root.setProperty('--theme-800', `rgba(${r}, ${g}, ${b}, 1)`);
                    // Text/Accent color
                    
                    currentAppThemeHex.value = hexColor;
                };

                // --- Computed Â±¨ÊÄß ---
                
                const today = computed(() => new Date().toISOString().split('T')[0]);
                const currentEvent = computed(() => {
                    return events.value.find(e => e.id === activeEventId.value);
                });
                const eventYears = computed(() => {
                    return [...new Set(events.value.map(e => e.year))].sort((a, b) => b - a);
                });
                const upcomingEvents = computed(() => {
                    if (!Array.isArray(events.value)) return []; // FIX 1
                    return events.value.filter(e => e.date && e.date >= today.value).sort((a, b) => a.date.localeCompare(b.date));
                });
                const pastEvents = computed(() => {
                    if (!Array.isArray(events.value)) return []; // FIX 1
                    return events.value.filter(e => e.date && e.date < today.value).sort((a, b) => b.date.localeCompare(a.date));
                });
                const mapLink = computed(() => {
                    const event = currentEvent.value;
                    if (!event) return null;
                    let locationToSearch = '';
                    let sourceText = '';
   
                    if (event.mainLocation) {
                        locationToSearch = event.mainLocation;
                        sourceText = '‰∏ªË¶ÅÂú∞Èªû';
                    } 
        
                    else if (event.dailyItems && event.dailyItems.length > 0 && event.dailyItems[event.dailyItems.length - 1].location) {
                        locationToSearch = event.dailyItems[event.dailyItems.length - 1].location;
                        sourceText = 'ÊúÄÂæå‰∏ÄÁ´ô';
                    }
   
                    if (locationToSearch) {
                        return {
                            // ‰øÆÊ≠£Âú∞ÂúñÈÄ£ÁµêË™ûÊ≥ïÔºö‰ΩøÁî®Ê≠£Á¢∫ÁöÑ Google Maps ÊêúÂ∞ã URL Ê†ºÂºè‰∏¶‰ΩøÁî® ${}
                            url: `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(locationToSearch)}`,
                            source: sourceText
                        };
                    }
                    return null;
                });

                // --- Review/Stats Logic ---
                
                const eventsInSelectedScope = computed(() => {
                    if (!Array.isArray(events.value)) return []; // FIX 1
                    return events.value.filter(event => 
         
                       selectedReviewYear.value === 'all' || event.year === parseInt(selectedReviewYear.value)
                    ).sort((a, b) => b.date.localeCompare(a.date)); 
                });
                const achievementsEvents = computed(() => {
                    const EXCLUDED_KEYWORDS = ['ÏÇ¨Ï†ÑÎÖπÌôî', '‰∫ãÂâçÈåÑË£Ω', 'Á∞ΩÂîÆÊúÉ', 'Á∞ΩÂêçÊúÉ', 'ÈåÑË£Ω'];
                    const eventsToFilter = eventsInSelectedScope.value;

                    return eventsToFilter.filter(event => 
                      
                        !EXCLUDED_KEYWORDS.some(keyword => event.eventName && event.eventName.includes(keyword))
                    );
                });
                const overallStats = computed(() => {
                    const eventList = achievementsEvents.value; 
                    const totalEventsAll = eventsInSelectedScope.value.length; 
                    
                    if (eventList.length === 0) {
   
                        return {
                            totalEventsAll: totalEventsAll,
                            totalEventsFiltered: 0,
                    
                            uniqueArtists: 0,
                            artistBreakdown: [],
                            eventRepetitionBreakdown: [],
                            totalExpense: 0, 
   
                            avgExpensePerEvent: 0, 
                            expenseBreakdown: [],
                        };
                    
                    }
                    
                    const totalEventsFiltered = eventList.length;
                    const artists = {};
                    const eventNames = {};
           
                    let totalExpense = 0; 

                    const expenseBreakdown = {};
                    for (const event of eventsInSelectedScope.value) {
                        // MODIFIED: Sum expenses from dailyItems/expenseAmount AND baseTicketExpense
                        const dailyTotal = event.dailyItems 
                            ?
                            event.dailyItems.reduce((sum, item) => sum + (item.expenseAmount || 0), 0) 
                            : 0;
                        const ticketExpense = parseFloat(event.baseTicketExpense || 0); 
                        const eventTotal = dailyTotal + ticketExpense;

                        totalExpense += eventTotal;
                        
                        const year = event.year;
                        expenseBreakdown[year] = (expenseBreakdown[year] || 0) + eventTotal;
                    }

                    // Tally Achivement Events data
                    for (const event of eventList) {
                        const artist = event.artistName ||
'Êú™Áü•Ê≠åÊâã';
                        artists[artist] = (artists[artist] || 0) + 1;
                        const eventName = event.eventName || 'Êú™Áü•Ê¥ªÂãï';
                        eventNames[eventName] = (eventNames[eventName] || 0) + 1;
                    }


                    const uniqueArtists = Object.keys(artists).length;
                    const avgExpensePerEvent = totalEventsAll > 0 ? (totalExpense / totalEventsAll).toFixed(0) : 0;
                    const artistBreakdown = Object.entries(artists)
                        .map(([name, count]) => ({ name, count }))
                        .sort((a, b) => b.count - a.count);
                    const eventRepetitionBreakdown = Object.entries(eventNames)
                        .map(([name, count]) => ({ name, count }))
                        .filter(item => item.count > 1) 
                        .sort((a, b) => b.count - a.count);
                    return {
                        totalEventsAll,
                        totalEventsFiltered,
                        uniqueArtists,
                        artistBreakdown,
   
                        eventRepetitionBreakdown,
                        totalExpense: totalExpense.toFixed(2),
                        avgExpensePerEvent,
                        expenseBreakdown,
      
                    };
                });
                // --- Ë®òÂ∏≥ÈÇèËºØ ---
                const expenseSummary = computed(() => {
                    const event = currentEvent.value;
                    if (!event || !event.dailyItems) {
                        return { totalSpent: 0 };
 
                    }
                    // MODIFIED: Sum expenses from dailyItems/expenseAmount AND baseTicketExpense
                    const dailyTotal = event.dailyItems.reduce((sum, item) => sum + (item.expenseAmount || 0), 0);
                    const ticketExpense = 
parseFloat(event.baseTicketExpense || 0);
                    const totalSpent = dailyTotal + ticketExpense;

                    return { totalSpent: totalSpent.toFixed(2) };
                });
                // --- Áç≤ÂèñÂñÆÂÄãË°åÁ®ãÁöÑÁ∏ΩËä±Ë≤ª (Áî®ÊñºË°åÁ®ãÂàóË°®) ---
                const getEventTotalExpense = (event) => {
                    if (!event || !event.dailyItems) return '0.00';
                    // MODIFIED: Sum expenses from dailyItems/expenseAmount AND baseTicketExpense
                    const dailyTotal = event.dailyItems.reduce((sum, item) => sum + (item.expenseAmount || 0), 0);
                    const ticketExpense = parseFloat(event.baseTicketExpense || 0);
                    const totalSpent = dailyTotal + ticketExpense;
                    return totalSpent.toFixed(2);
                };
                
                // ------------------ Firestore CRUD ÂáΩÊï∏ -------------------
                
                const getEventCollectionRef = () => {
                    const userDir = userId.value ?
`/artifacts/${appId}/users/${userId.value}` : '';
                    return collection(db, `${userDir}/schedules`);
                };

                const getColorDocRef = () => {
                    const userDir = userId.value ?
`/artifacts/${appId}/users/${userId.value}` : '';
                    return doc(db, `${userDir}/fan_colors/colors`);
                }

                const getThemeDocRef = () => {
                     const userDir = userId.value ?
`/artifacts/${appId}/users/${userId.value}` : '';
                    return doc(db, `${userDir}/app_theme/theme`);
                }
                
                // „ÄêÊñ∞Â¢ûÂäüËÉΩÔºöÂàùÊ¨°ËºâÂÖ•ÊôÇÂåØÂÖ•È†êË®≠Ê¥ªÂãï„Äë
                const importDefaultEvents = async (eventsRef) => {
                    if (DEFAULT_EVENTS.length === 0) return;
                    console.log('Firestore is empty. Importing default events...');
                    
                    const batch = writeBatch(db);
                    DEFAULT_EVENTS.forEach(eventData => {
                        const newDocRef = doc(eventsRef); 
                        batch.set(newDocRef, eventData);
                    });

                    try {
                        await batch.commit();
                        console.log(`Default events imported successfully: ${DEFAULT_EVENTS.length} items.`);
                    } catch (e) {
                        console.error("Error importing default events:", e);
                    }
                };


                const subscribeToEvents = () => {
                    if (unsubscribeEvents) unsubscribeEvents();
                    if (unsubscribeColors) unsubscribeColors();
                    if (unsubscribeTheme) unsubscribeTheme();
                    if (!userId.value) return;

                    const eventsRef = getEventCollectionRef();
                    unsubscribeEvents = onSnapshot(eventsRef, (snapshot) => {
                        const fetchedEvents = [];
                        snapshot.forEach((doc) => fetchedEvents.push({ id: doc.id, ...doc.data() }));
                        
                        // „ÄêÊ™¢Êü•‰∏¶ËºâÂÖ•È†êË®≠Ë≥áÊñô„Äë
                        if (snapshot.empty && !loading.value) { // Âè™ÊúâÂú®Êï∏ÊìöÂ∫´ÁÇ∫Á©∫‰∏î‰∏çÊòØÈ¶ñÊ¨°Âä†ËºâÊôÇÔºàÈÅøÂÖçÈáçË§áËß∏ÁôºÔºâ
                           // È¶ñÊ¨°ËºâÂÖ•ÊôÇÊ™¢Êü•ÊòØÂê¶ÁÇ∫Á©∫
                           if (loading.value === true) {
                               importDefaultEvents(eventsRef);
                           }
                        }
                        
                        events.value = fetchedEvents;
                        loading.value = false;
                        
                        if (currentEvent.value && currentEvent.value.participants.length > 0) {
                             // Removed: newExpense.value.participants logic
                        }
                    }, (error) => { console.error("Error fetching events:", error); loading.value = false; });
                    
                    const colorsRef = getColorDocRef();
                    unsubscribeColors = onSnapshot(colorsRef, (doc) => {
                        fanColors.value = doc.data() || {};
                    }, (error) => { console.error("Error fetching fan colors:", error); });
                    
                    // NEW: Subscribe to Theme
                    const themeRef = getThemeDocRef();
                    unsubscribeTheme = onSnapshot(themeRef, (doc) => {
                        const data = doc.data();
                        const hexColor = data ? (data.hex || INITIAL_APP_THEME_HEX) : INITIAL_APP_THEME_HEX;
                        applyTheme(hexColor);
           
                        newThemeSelectionHex.value = hexColor;
                    }, (error) => { console.error("Error fetching app theme:", error); });
                };
                
                const handleAuth = async () => {
                    try {
                        // Ê™¢Êü• Firebase ÈÖçÁΩÆÊòØÂê¶ÁÇ∫Á©∫ÔºåÊèêÈÜíÁî®Êà∂ÊõøÊèõ
                        if (Object.keys(firebaseConfig).length === 0 || !firebaseConfig.projectId) {
                             alert("ÈåØË™§ÔºöË´ãÂÖàÂú®Á®ãÂºèÁ¢ºÈñãÈ†≠ÊõøÊèõÊÇ®ÁöÑ Firebase Â∞àÊ°àÈÖçÁΩÆÔºÅ");
                             isAuthReady.value = true; loading.value = false;
                             return;
                        }

                        app = initializeApp(firebaseConfig);
                        db = getFirestore(app);
                        auth = getAuth(app);
                        // ÂòóË©¶‰ΩøÁî® initialAuthToken (Â¶ÇÊûúÊúâÁöÑË©±Ôºå‰ΩÜÊàëÂÄëÂú®Á°¨Á∑®Á¢ºÊôÇË®≠ÁÇ∫ null)
                        if (initialAuthToken) await signInWithCustomToken(auth, initialAuthToken);
                        // Âê¶Ââá‰ΩøÁî®ÂåøÂêçÁôªÂÖ•
                        else await signInAnonymously(auth);
                        onAuthStateChanged(auth, (user) => {
                            if (user) { userId.value = user.uid; isAuthReady.value = true; subscribeToEvents(); } 
                            else { console.log("User signed out or failed to sign in."); userId.value = null; isAuthReady.value = true; loading.value = false; }
           
                        });
                    } catch (error) { console.error("Firebase Initialization/Auth Error:", error); isAuthReady.value = true; loading.value = false;
                    }
                };
                // NEW: È°èËâ≤ÁÆ°ÁêÜ CRUD
                const addOrUpdateColor = async () => {
                    if (!newColorArtist.value || !newColorClass.value) return;
                    const artist = newColorArtist.value.trim();
                    const color = newColorClass.value.trim().toUpperCase();

                    // Validation for HEX
                    if (!/^#([0-9A-F]{3}){1,2}$/.test(color)) {
                        alert('ÊáâÊè¥Ëâ≤ÂøÖÈ†àÊòØÊúâÊïàÁöÑ HEX Ëâ≤Á¢º (‰æãÂ¶Ç: #FF4B91)');
                        return;
                    }

                    try {
                        await setDoc(getColorDocRef(), {
                            [artist]: color
                       
                        }, { merge: true });
                        newColorArtist.value = '';
                        newColorClass.value = '#EF4444';
                    } catch (e) {
                        console.error("Error saving color:", e);
                    }
                };
                const deleteColor = async (artist) => {
                    try {
                        const updatedColors = { ...fanColors.value };
                        delete updatedColors[artist];
                        await setDoc(getColorDocRef(), updatedColors, { merge: false });
                    } catch (e) {
                        console.error("Error deleting color:", e);
                    }
                };
                // NEW: ‰∏ªÈ°åË®≠ÂÆö CRUD
                const saveAppTheme = async () => {
                    const hex = newThemeSelectionHex.value.toUpperCase();
                    if (!/^#([0-9A-F]{3}){1,2}$/.test(hex)) {
                        alert('Ë´ãËº∏ÂÖ•ÊúâÊïàÁöÑ HEX Ëâ≤Á¢º (‰æãÂ¶Ç: #FF4B91)');
                        return;
                    }
                    try {
                        await setDoc(getThemeDocRef(), { hex: hex }, { merge: true });
                        applyTheme(hex); 
                        showColorModal.value = false;
                    } catch (e) {
                        console.error("Error saving app theme:", e);
                    }
                };
                const convertYYMMDDToYYYYMMDD = (yyMMDD) => {
                    if (yyMMDD.length !== 6) return '';
                    const yy = yyMMDD.substring(0, 2); const mm = yyMMDD.substring(2, 4); const dd = yyMMDD.substring(4, 6);
                    const year = '20' + yy; return `${year}-${mm}-${dd}`;
                };
                
                const handleFileSelect = (event) => {
                    const files = event.target.files;
                    if (files.length > 0) selectedFile.value = files[0]; else selectedFile.value = null;
                };
                const importCSV = () => {
                    if (!selectedFile.value || isImporting.value) return;
                    isImporting.value = true; const reader = new FileReader();

                    reader.onload = async (e) => {
                        const csvText = e.target.result;
                        const lines = csvText.trim().split('\n');
                        if (lines.length < 2) { console.error('ÈåØË™§ÔºöCSVÊ™îÊ°àÂÖßÂÆπ‰∏çË∂≥„ÄÇ'); isImporting.value = false; return;
                        }
                        const header = lines[0].trim().split(',');
                        const dataLines = lines.slice(1); let importedCount = 0; let errorCount = 0;
                        const dateIndex = header.indexOf('Êó•Êúü'); const artistIndex = header.indexOf('Ê≠åÊâã');
                        const eventNameIndex = header.indexOf('Ê¥ªÂãïÂêçÁ®±'); const locationIndex = header.indexOf('Âú∞Èªû');
                        if (dateIndex === -1 || artistIndex === -1 || eventNameIndex === -1 || locationIndex === -1) { console.error('ÈåØË™§ÔºöCSVÊ®ôÈ°å‰∏çÁ¨¶ÂêàÈ†êÊúü (ÈúÄÂåÖÂê´ÔºöÊó•Êúü,Ê≠åÊâã,Ê¥ªÂãïÂêçÁ®±,Âú∞Èªû)„ÄÇ');
                        isImporting.value = false; return; }
                        for (const line of dataLines) {
                            if (!line.trim()) continue;
                            const values = line.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(v => v.trim()); 
                            if (values.length > Math.max(dateIndex, artistIndex, eventNameIndex, locationIndex)) {
                                let rawDate = values[dateIndex].replace(/"/g, '').trim();
                                let date = convertYYMMDDToYYYYMMDD(rawDate); let eventDate = new Date(date);
                                if (!date || isNaN(eventDate)) { errorCount++;
                                console.warn(`Skipping line due to invalid date: ${line}`); continue; }
                                let eventName = values[eventNameIndex].trim().replace(/^"|"$/g, '').replace(/""/g, '"'); let artistName = values[artistIndex].trim().replace(/"/g, '').trim();
                                let mainLocation = values[locationIndex].trim().replace(/"/g, '').trim();
                                const newEvent = { eventName: eventName || 'ÁÑ°Ê¥ªÂãïÂêçÁ®±', artistName: artistName || 'ÁÑ°Ê≠åÊâã', year: eventDate.getFullYear(), date: date, mainLocation: mainLocation || 'Êú™Ë®≠ÂÆöÂú∞Èªû', dailyItems: [], baseTicketExpense: 0, participants: ['Êàë'] };
                                try { await addDoc(getEventCollectionRef(), newEvent); importedCount++; 
                                } catch (e) { console.error("Error adding document during import: ", e); errorCount++; }
                            } else { errorCount++; console.warn(`Skipping line due to insufficient fields: ${line}`); }
                        }
                        isImporting.value 
                        = false; selectedFile.value = null; document.getElementById('csvFile').value = ''; showImportModal.value = false;
                        console.log(`ÂåØÂÖ•ÂÆåÊàêÔºÅÊàêÂäüÂåØÂÖ• ${importedCount} ÂÄãË°åÁ®ã„ÄÇ (Êúâ ${errorCount} ÂÄãË°åÁ®ãÂõ†Ê†ºÂºèÈåØË™§ËÄåË¢´Ë∑≥ÈÅé)`);
                    };
                    reader.onerror = () => { isImporting.value = false;
                    console.error('Ê™îÊ°àËÆÄÂèñÂ§±Êïó„ÄÇ'); };
                    reader.readAsText(selectedFile.value, 'UTF-8');
                };

                const addEvent = async () => {
                    if (!newEventName.value || !newArtistName.value || !newEventDate.value) return;
                    if (!userId.value) { console.error("Authentication not ready."); return; }
                    const eventDate = new Date(newEventDate.value);
                    const eventYear = eventDate.getFullYear();
                    const newEvent = { eventName: newEventName.value, artistName: newArtistName.value, year: eventYear, date: newEventDate.value, mainLocation: newEventLocation.value, dailyItems: [], expenses: [], participants: ['Êàë'] };
                    try {
                        const docRef = await addDoc(getEventCollectionRef(), newEvent);
                        activeEventId.value = docRef.id; showEventModal.value = false;
                        newEventName.value = ''; newArtistName.value = ''; newEventDate.value = ''; newEventLocation.value = '';
                    } catch (e) { console.error("Error adding document: ", e); }
                };
                const deleteEvent = async (id) => {
                    if (confirm('Á¢∫ÂÆöË¶ÅÂà™Èô§ÈÄôÂÄãË°åÁ®ãÂóéÔºüÊ≠§Êìç‰ΩúÁÑ°Ê≥ïÊí§Èä∑„ÄÇ')) { 
                        try { await deleteDoc(doc(getEventCollectionRef(), id));
                        if (activeEventId.value === id) activeEventId.value = null; } 
                        catch (e) { console.error("Error deleting document: ", e);
                        }
                    }
                };
                const updateEvent = async (updatedData) => {
                    if (!currentEvent.value) return;
                    try { const eventRef = doc(getEventCollectionRef(), activeEventId.value); await setDoc(eventRef, updatedData, { merge: true });
                    } 
                    catch (e) { console.error("Error updating document: ", e);
                    }
                };
                const loadEditForm = () => {
                    if (!currentEvent.value) return;
                    editEventForm.value = {
                        eventName: currentEvent.value.eventName,
                        artistName: currentEvent.value.artistName,
                        date: currentEvent.value.date,
                       
                        time: currentEvent.value.time || '', // LOAD TIME
                        mainLocation: currentEvent.value.mainLocation,
                        baseTicketExpense: parseFloat(currentEvent.value.baseTicketExpense || 0), 
                        id: currentEvent.value.id
               
                    };
                    showEditModal.value = true;
                };
                const saveEditedEvent = async () => {
                    if (!editEventForm.value.eventName || !editEventForm.value.artistName || !editEventForm.value.date || !editEventForm.value.id) return;
                    const newDate = editEventForm.value.date; const newYear = new Date(newDate).getFullYear();
                    const updatedData = { 
                        eventName: editEventForm.value.eventName, 
                        artistName: editEventForm.value.artistName, 
                        date: newDate, 
         
                        time: editEventForm.value.time, // SAVE TIME
                        year: newYear, 
                        mainLocation: editEventForm.value.mainLocation,
                        baseTicketExpense: parseFloat(editEventForm.value.baseTicketExpense) ||
0 
                    };
                    try { await updateDoc(doc(getEventCollectionRef(), editEventForm.value.id), updatedData); showEditModal.value = false; } 
                    catch (e) { console.error("Error saving edited document: ", e);
                    }
                };
                const addParticipant = async () => {
                    const name = newParticipant.value.trim();
                    if (!currentEvent.value || !name || currentEvent.value.participants.includes(name) || name === '') return;
                    const updatedParticipants = [...currentEvent.value.participants, name];
                    await updateEvent({ participants: updatedParticipants }); newParticipant.value = '';
                };

                const removeParticipant = async (name) => {
                    if (!currentEvent.value || name === 'Êàë') return;
                    if (confirm(`Á¢∫ÂÆöË¶ÅÂ∞á ${name} ÂæûÂèÉËàáËÄÖÂêçÂñÆ‰∏≠ÁßªÈô§ÂóéÔºüÁßªÈô§ÂæåÔºå‰ªñÁöÑÊâÄÊúâÊîØÂá∫/ÂàÜÊî§Ë®òÈåÑÂ∞áÊúÉË¢´Êõ¥Êñ∞„ÄÇ`)) {
                        const updatedParticipants = currentEvent.value.participants.filter(p => p !== name);
                        const updatedExpenses = currentEvent.value.expenses.map(exp => ({ ...exp, payer: exp.payer === name ? 'Êàë' : exp.payer, participants: exp.participants.filter(p => p !== name) }));
                        await updateEvent({ participants: updatedParticipants, expenses: updatedExpenses });
                    }
                };
                const addDailyItem = async () => {
                    if (!currentEvent.value || !newSchedule.value.location) return;
                    const expenseAmount = parseFloat(newSchedule.value.expenseAmount) || 0;
                    const expenseDescription = newSchedule.value.expenseDescription || (expenseAmount > 0 ? 'Êú™ÂëΩÂêçÊîØÂá∫' : '');
                    const updatedItems = [...currentEvent.value.dailyItems, { 
                        time: newSchedule.value.time, 
                        location: newSchedule.value.location, 
                        description: newSchedule.value.description,
                  
                        expenseAmount: expenseAmount, 
                        expenseDescription: expenseDescription, 
                        id: crypto.randomUUID() 
                    }];
                    await updateEvent({ dailyItems: updatedItems }); 
                    
                    newSchedule.value = { 
                        time: '09:00', 
                        location: '', 
                        description: '', 
              
                        expenseAmount: 0, 
                        expenseDescription: '' 
                    };
                };

                const deleteDailyItem = async (itemId) => {
                    if (!currentEvent.value) return;
                    const updatedItems = currentEvent.value.dailyItems.filter(item => item.id !== itemId);
                    await updateEvent({ dailyItems: updatedItems });
                };
                const addExpense = async () => {
                    alert('Ê≠§ÊåâÈàïÂ∑≤Ë¢´ÁßªÈô§„ÄÇË´ãÈÄèÈÅé„ÄåÊñ∞Â¢ûÊØèÊó•Ë°åÁ®ãÈ†ÖÁõÆ„Äç‰æÜË®òÈåÑÊîØÂá∫„ÄÇ');
                };

                const deleteExpense = async (expenseId) => {
                    if (!currentEvent.value) return;
                    const updatedExpenses = currentEvent.value.expenses.filter(item => item.id !== expenseId);
                    await updateEvent({ expenses: updatedExpenses });
                };

                handleAuth();
                return {
                    loading, isAuthReady, events, activeEventId, activeTab, 
                    newEventName, newArtistName, showEventModal, showEditModal, editEventForm, 
                    newEventDate, newEventLocation, newSchedule, newExpense, selectedReviewYear, 
                    showExclusionDisclaimer, selectedFile, isImporting, showImportModal, 
                    handleFileSelect,
                    importCSV, newParticipant, currentEvent, eventYears, eventsInSelectedScope, 
                    overallStats, mapLink, expenseSummary, upcomingEvents, pastEvents, getEventTotalExpense, 
                    getFanColorClass, 
                    
        
                    // Color Management
                    fanColors,
                    showColorModal,
                    newColorArtist,
                    newColorClass,
      
                    addOrUpdateColor,
                    deleteColor,

                    // Theme Management
                    currentAppThemeHex,
                    newThemeSelectionHex,
    
                    saveAppTheme,
                    
                    showDailyItemModal,
                    showEntrySelectionModal, 

                    setActiveEvent: (id) => 
{ activeEventId.value = id; activeTab.value = 'info'; },
                    setActiveTab: (tab) => activeTab.value = tab,
                    goToEventList: () => { activeEventId.value = null;
activeTab.value = 'schedule'; }, 
                    addEvent, deleteEvent, loadEditForm, saveEditedEvent, addParticipant, removeParticipant,
                    addDailyItem, deleteDailyItem, addExpense, deleteExpense,
                };
            }
        };

        // Custom Tailwind Configuration (Uses CSS variables for main theme, standard colors forÊáâÊè¥Ëâ≤)
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                  
                        // Dynamically inject theme base using CSS variables
                        'app-theme': {
                            50: 'rgba(var(--theme-rgb), 0.05)',
                            100: 'rgba(var(--theme-rgb), 0.1)',
  
                            400: 'rgba(var(--theme-rgb), 0.6)', // Used for borders, lighter elements
                            500: 'rgba(var(--theme-rgb), 0.8)', // Main buttons/nav color
                            600: 'rgba(var(--theme-rgb), 0.9)',
  
                            700: 'var(--theme-hex)', // Used for text, primary color
                            800: 'var(--theme-hex)', // Used for text, darker color
                        },
        
                        // Standard colors for fan themes (NOTE: We rely on JIT binding for user-input colors)
                        'aquamarine': { 400: '#4FBDBA', 500: '#349996', 100: '#d9fffd', 700: '#235c59', 800: '#1b3d3c', 50: '#f0fffe' },
                        // Include a few common colors as fallbacks 
                        'red': { 500: '#EF4444' }, 
                        'blue': { 500: '#3B82F6' },
                        'gray':
